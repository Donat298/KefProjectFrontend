/*
Let's now try to split the place bet function.
 Because at the moment, in this function, both the bet and the receipt of winnings are made.
 Same on backend with router.put('/games/crash',
 Can you make it so in the backland that the acceptance of the bet is router.put('/games/crash', and the calculation itself. 
 It was in router.put('/games/crash/cashout'
 The same on the frontend, divide the placeBet function into 2 requests /games/crash and games /games/crash/cashout ,
 so that /games/crash itself is in /games/crash, 
 and the request and the bet itself in cashout already have a request for calculations and receipt of winnings.



 //Frontend side
  <script>
  import { ref, computed, onMounted, onUnmounted } from 'vue';
  import { useStore } from 'vuex';
  import { useRouter } from 'vue-router';
  import { useApiPrivate } from '../../utils/useApi';
  import GameAlert from './GameAlert.vue';

  export default {
    components: {
      GameAlert
    },
    setup() {
      const store = useStore();
      const axiosPrivateInstance = useApiPrivate(store);
      const betInput = ref('');
      const gameResult = ref(null);
      const errorMsg = ref('');
      const showAlert = ref(true);
      const isProcessing = ref(false);
      const router = useRouter();
  
      const roundBalance = (value) => {
        if (value > 10000000) {
          return 10000000;
        }
        return Math.round(value * 10000000) / 10000000;
      };
  
      const tempBalance = computed(() => {
        const currentBalance = roundBalance(store.getters.userDetail[store.getters.selectedCurrency] - parseFloat(betInput.value));
        return isProcessing.value ? currentBalance : roundBalance(store.getters.userDetail[store.getters.selectedCurrency]);
      });
  
      const placeBet = async () => {
        errorMsg.value = '';
        betInput.value = roundBalance(parseFloat(betInput.value));
  
        if (!store.getters.isAuthenticated) {
          router.push('/auth/register');
          return;
        }
  
        if (betInput.value < 0) {
          errorMsg.value = 'The bet cannot be less than zero.';
          return;
        }
  
        if (store.getters.userDetail[store.getters.selectedCurrency] < betInput.value) {
          errorMsg.value = 'Your balance is less than the bet amount';
          return;
        }
  
        isProcessing.value = true;
        showAlert.value = false;
  
        try {
          const balanceFieldsMap = {
            'balance': 'trc',
            'balanceeur': 'eur',
            'balancebtc': 'btc',
            'balanceeth': 'eth',
          };
  
          const currency = balanceFieldsMap[store.getters.selectedCurrency];
  
          const response = await axiosPrivateInstance.put('/games/crash', {
            betAmount: betInput.value,
            currency: currency
          });
  
          const newAmount = roundBalance(store.getters.userDetail[store.getters.selectedCurrency] - betInput.value);
          store.dispatch('updateBalance', { currency: currency, amount: newAmount });
  
          gameResult.value = {
            won: response.data.message === 'You won!',
            balance: roundBalance(response.data.balance)
          };
  
          store.dispatch('updateBalance', { currency: currency, amount: roundBalance(response.data.balance) });
          isProcessing.value = false;
          showAlert.value = true;
        } catch (error) {
          console.log(error);
  
          if (error.response && error.response.data && error.response.data.message) {
            errorMsg.value = error.response.data.message;
          } else {
            errorMsg.value = "An unknown error occurred.";
          }
  
          isProcessing.value = false;
          showAlert.value = true;
        }
      };
      const enterListener = (event) => {
      if (event.key === 'Enter') {
        event.preventDefault(); // Prevent the default behavior of the Enter key
        if (!isProcessing.value) {
          placeBet(); // Place the bet if not already processing
        }
      }
    };

    onMounted(() => {
      window.addEventListener('keydown', enterListener);
    });

    onUnmounted(() => {
      window.removeEventListener('keydown', enterListener);
    });
  
      return {
        placeBet,
        betInput,
        gameResult,
        errorMsg,
        isProcessing,
        tempBalance,
        showAlert,
      };
    },
  };
  </script>


  //Backend side
const express = require('express');
const router = express.Router();
const User = require('../models/User');
const verifyToken = require('../middleware/verifyToken');

router.put('/games/crash', verifyToken, async (req, res, next) => {
  const { betAmount, currency } = req.body;
  const userId = req.user.id;

  try {
    const user = await User.findById(userId);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const balanceFieldsMap = {
      'trc': 'balance',
      'eur': 'balanceeur',
      'btc': 'balancebtc',
      'eth': 'balanceeth',
    }

    const currentBalance = user[balanceFieldsMap[currency]];

    // Check if betAmount is a negative number or greater than user balance
    if (betAmount < 0 || betAmount > currentBalance) {
      return res.status(400).json({ message: "Invalid bet amount" });
    }

    // Deduct bet from user's balance immediately
    user[balanceFieldsMap[currency]] -= betAmount;
    
    const userWon = Math.random() >= 0.5;

    if (userWon) {
      user[balanceFieldsMap[currency]] += betAmount * 2;
    }

    await user.save();

    return res.json({ 
      balance: user[balanceFieldsMap[currency]],
      message: userWon ? 'You won!' : 'You lost, better luck next time.'
    });

  } catch (err) {
   
    next(err);
  }
});

module.exports = router;

*/ 